<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-key>4-2-trending-topics-velocity</story-key>
    <story-title>Trending Topics/Pillars by Velocity (24-72h)</story-title>
    <epic>Epic 4: Insights + Daily Brief + Recommendations (MVP)</epic>
    <status>ready-for-dev</status>
    <generated-date>2025-01-14</generated-date>
    <prerequisites>
      <prerequisite>Story 4.1: Auto Keyword Tagging (provides tag data)</prerequisite>
      <prerequisite>Story 2.3: Ingest Daily Metrics (provides engagement data)</prerequisite>
      <prerequisite>Story 3.1: Page Groups (enables niche filtering)</prerequisite>
    </prerequisites>
    <enables>
      <enables-story>Story 4.4: Daily Brief (uses trending topics for insights)</enables-story>
    </enables>
  </metadata>

  <story-definition>
    <user-story>
      As a Leader,
      I want a list of trending topics/pillars by velocity,
      So that I can catch trends quickly within each niche.
    </user-story>

    <acceptance-criteria>
      <criterion id="AC1">
        Given tags and metrics time-series,
        When Leader views Insights,
        Then system displays top trending topics/pillars by group/niche.
      </criterion>
      <criterion id="AC2">
        And trend shows "why" explanation (velocity + metrics).
      </criterion>
      <criterion id="AC3">
        And trending is calculated over 24-72 hour windows.
      </criterion>
      <criterion id="AC4">
        And trends can be filtered by group/niche.
      </criterion>
      <criterion id="AC5">
        And trending topics are ranked by velocity score.
      </criterion>
    </acceptance-criteria>

    <technical-requirements>
      <requirement>Calculate tag mention velocity over time windows</requirement>
      <requirement>Calculate engagement velocity per tag</requirement>
      <requirement>Compute weighted velocity score</requirement>
      <requirement>Support multiple time windows (24h, 48h, 72h)</requirement>
      <requirement>Filter by group/niche</requirement>
      <requirement>Generate "why trending" explanations</requirement>
      <requirement>Rank topics by velocity score</requirement>
      <requirement>Frontend widget for trending display</requirement>
    </technical-requirements>
  </story-definition>

  <velocity-calculation>
    <description>Formula for calculating trending velocity based on tag mentions and engagement</description>
    
    <simple-velocity>
      <formula>
        Velocity = ((Current Period Mentions - Previous Period Mentions) / Previous Period Mentions) √ó 100
      </formula>
      <use-case>Basic mention-based trending</use-case>
    </simple-velocity>

    <weighted-velocity>
      <formula>
        Weighted Velocity = (Mention Velocity √ó 0.4) + (Engagement Velocity √ó 0.6)
        
        Where:
        - Mention Velocity = ((Current Mentions - Previous Mentions) / Previous Mentions) √ó 100
        - Engagement Velocity = ((Current Avg Engagement - Previous Avg Engagement) / Previous Avg Engagement) √ó 100
      </formula>
      <use-case>Recommended for MVP - combines quantity and quality</use-case>
      <weights>
        <mention-weight>0.4 (40%)</mention-weight>
        <engagement-weight>0.6 (60%)</engagement-weight>
      </weights>
      <rationale>Engagement is weighted higher to prioritize quality over quantity</rationale>
    </weighted-velocity>

    <example-calculation>
      <scenario>Tag "AI" trending analysis</scenario>
      <previous-period>
        <mentions>10 content items</mentions>
        <total-engagement>500</total-engagement>
        <avg-engagement>50 per item</avg-engagement>
      </previous-period>
      <current-period>
        <mentions>18 content items</mentions>
        <total-engagement>1260</total-engagement>
        <avg-engagement>70 per item</avg-engagement>
      </current-period>
      <calculation>
        <mention-velocity>((18 - 10) / 10) √ó 100 = 80%</mention-velocity>
        <engagement-velocity>((70 - 50) / 50) √ó 100 = 40%</engagement-velocity>
        <weighted-velocity>(80 √ó 0.4) + (40 √ó 0.6) = 32 + 24 = 56%</weighted-velocity>
      </calculation>
      <result>
        <velocity-score>56.0%</velocity-score>
        <interpretation>Tag "AI" is strongly trending with high mention growth and moderate engagement growth</interpretation>
      </result>
    </example-calculation>

    <edge-cases>
      <case name="new-tag">
        <scenario>Tag appears for first time (previous mentions = 0)</scenario>
        <handling>Set velocity to 100% (maximum growth from zero)</handling>
        <mark-as-new>true</mark-as-new>
      </case>
      <case name="zero-baseline">
        <scenario>Previous period has zero mentions or engagement</scenario>
        <handling>Avoid division by zero, return 100% velocity</handling>
      </case>
      <case name="declining-trend">
        <scenario>Current mentions/engagement less than previous</scenario>
        <handling>Negative velocity, filtered out from trending list</handling>
        <rationale>Only show trending up, not declining</rationale>
      </case>
      <case name="stable-trend">
        <scenario>Same mentions and engagement in both periods</scenario>
        <handling>Velocity = 0%, not included in trending</handling>
      </case>
    </edge-cases>
  </velocity-calculation>

  <service-implementation>
    <class-name>AnalyticsTrendingService</class-name>
    <location>libraries/nestjs-libraries/src/database/prisma/analytics/analytics-trending.service.ts</location>

    <main-method>
      <signature>
        ```typescript
        async getTrendingTopics(
          organizationId: string,
          options: {
            groupId?: string;
            integrationIds?: string[];
            timeWindow: '24h' | '48h' | '72h';
            limit?: number;
          }
        ): Promise&lt;TrendingTopic[]&gt;
        ```
      </signature>

      <implementation>
        ```typescript
        async getTrendingTopics(organizationId: string, options: TrendingOptions) {
          const limit = options.limit || 10;
          const hours = this.parseTimeWindow(options.timeWindow);

          // Calculate time periods
          const now = new Date();
          const currentPeriodStart = dayjs(now).subtract(hours, 'hours').toDate();
          const previousPeriodStart = dayjs(now).subtract(hours * 2, 'hours').toDate();
          const previousPeriodEnd = currentPeriodStart;

          // Get integration IDs if groupId provided
          const integrationIds = options.groupId
            ? await this.getIntegrationIdsFromGroup(organizationId, options.groupId)
            : options.integrationIds || [];

          // Get tag mentions for both periods
          const currentPeriodTags = await this.getTagMentions(
            organizationId, integrationIds, currentPeriodStart, now
          );
          const previousPeriodTags = await this.getTagMentions(
            organizationId, integrationIds, previousPeriodStart, previousPeriodEnd
          );

          // Calculate velocities
          const trendingTags = this.calculateVelocities(
            currentPeriodTags,
            previousPeriodTags
          );

          // Sort by velocity score (descending) and return top N
          return trendingTags
            .sort((a, b) => b.velocityScore - a.velocityScore)
            .slice(0, limit);
        }
        ```
      </implementation>

      <time-periods>
        <current-period>Last N hours (24, 48, or 72)</current-period>
        <previous-period>Previous N hours before current period</previous-period>
        <comparison>Current vs Previous to calculate velocity</comparison>
      </time-periods>
    </main-method>

    <helper-methods>
      <method name="getTagMentions">
        <purpose>Aggregate tag mentions and engagement for a time period</purpose>
        <returns>Array of tags with mention count and engagement metrics</returns>
        <implementation>
          ```typescript
          private async getTagMentions(
            organizationId: string,
            integrationIds: string[],
            startDate: Date,
            endDate: Date
          ) {
            // Query content with tags in period
            const content = await this._prismaService.analyticsContent.findMany({
              where: {
                organizationId,
                publishedAt: { gte: startDate, lte: endDate },
                ...(integrationIds.length > 0 && {
                  integrationId: { in: integrationIds }
                })
              },
              include: {
                tags: { include: { tag: true } },
                metrics: { where: { date: { gte: startDate, lte: endDate } } }
              }
            });

            // Aggregate by tag
            const tagMap = new Map();
            for (const item of content) {
              for (const { tag } of item.tags) {
                if (!tagMap.has(tag.id)) {
                  tagMap.set(tag.id, {
                    tag,
                    mentions: 0,
                    totalEngagement: 0,
                    contentIds: new Set()
                  });
                }
                const tagData = tagMap.get(tag.id);
                tagData.contentIds.add(item.id);
                tagData.mentions = tagData.contentIds.size;
                
                const contentEngagement = item.metrics.reduce((sum, m) =>
                  sum + (m.reactions || 0) + (m.comments || 0) + (m.shares || 0), 0
                );
                tagData.totalEngagement += contentEngagement;
              }
            }

            return Array.from(tagMap.values()).map(data => ({
              tag: data.tag,
              mentions: data.mentions,
              totalEngagement: data.totalEngagement,
              avgEngagement: data.mentions > 0 ? data.totalEngagement / data.mentions : 0
            }));
          }
          ```
        </implementation>
      </method>

      <method name="calculateVelocities">
        <purpose>Calculate velocity scores for all tags</purpose>
        <implementation>
          ```typescript
          private calculateVelocities(currentPeriod: any[], previousPeriod: any[]) {
            const previousMap = new Map(
              previousPeriod.map(item => [item.tag.id, item])
            );

            return currentPeriod.map(current => {
              const previous = previousMap.get(current.tag.id);

              // Handle new tags
              if (!previous) {
                return {
                  tag: current.tag,
                  currentMentions: current.mentions,
                  previousMentions: 0,
                  mentionVelocity: 100,
                  currentAvgEngagement: current.avgEngagement,
                  previousAvgEngagement: 0,
                  engagementVelocity: 100,
                  velocityScore: 100,
                  isNew: true
                };
              }

              // Calculate velocities
              const mentionVelocity = previous.mentions > 0
                ? ((current.mentions - previous.mentions) / previous.mentions) * 100
                : 0;
              const engagementVelocity = previous.avgEngagement > 0
                ? ((current.avgEngagement - previous.avgEngagement) / previous.avgEngagement) * 100
                : 0;

              // Weighted velocity score
              const velocityScore = (mentionVelocity * 0.4) + (engagementVelocity * 0.6);

              return {
                tag: current.tag,
                currentMentions: current.mentions,
                previousMentions: previous.mentions,
                mentionVelocity: Math.round(mentionVelocity * 10) / 10,
                currentAvgEngagement: Math.round(current.avgEngagement),
                previousAvgEngagement: Math.round(previous.avgEngagement),
                engagementVelocity: Math.round(engagementVelocity * 10) / 10,
                velocityScore: Math.round(velocityScore * 10) / 10,
                isNew: false
              };
            }).filter(item => item.velocityScore > 0); // Only trending up
          }
          ```
        </implementation>
      </method>
    </helper-methods>
  </service-implementation>

  <api-specification>
    <endpoint>
      <method>GET</method>
      <path>/api/analytics/trending/topics</path>

      <query-parameters>
        <param name="groupId" type="string" required="false" description="Filter by analytics group"/>
        <param name="integrationIds" type="string[]" required="false" description="Comma-separated integration IDs"/>
        <param name="timeWindow" type="enum" required="false" values="24h,48h,72h" default="24h"/>
        <param name="limit" type="number" required="false" default="10" max="50"/>
      </query-parameters>

      <controller-implementation>
        ```typescript
        @Get('/trending/topics')
        @ApiOperation({ summary: 'Get trending topics by velocity' })
        @ApiQuery({ name: 'groupId', required: false })
        @ApiQuery({ name: 'integrationIds', required: false, type: [String] })
        @ApiQuery({ name: 'timeWindow', required: false, enum: ['24h', '48h', '72h'] })
        @ApiQuery({ name: 'limit', required: false, type: Number })
        @ApiResponse({ status: 200, description: 'Trending topics returned' })
        async getTrendingTopics(
          @GetOrgFromRequest() org: Organization,
          @Query('groupId') groupId?: string,
          @Query('integrationIds') integrationIds?: string,
          @Query('timeWindow') timeWindow: '24h' | '48h' | '72h' = '24h',
          @Query('limit') limit: string = '10'
        ) {
          const trending = await this._trendingService.getTrendingTopics(org.id, {
            groupId,
            integrationIds: integrationIds?.split(',').filter(Boolean),
            timeWindow,
            limit: Math.min(parseInt(limit, 10), 50)
          });

          return {
            timeWindow,
            generatedAt: new Date().toISOString(),
            trending: trending.map(item => ({
              ...item,
              whyTrending: this.generateWhyTrending(item)
            }))
          };
        }

        private generateWhyTrending(item: any): string {
          if (item.isNew) {
            return `New trending topic with ${item.currentMentions} mentions`;
          }
          
          const parts = [];
          if (item.mentionVelocity > 0) {
            parts.push(`${item.mentionVelocity}% increase in mentions`);
          }
          if (item.engagementVelocity > 0) {
            parts.push(`${item.engagementVelocity}% increase in engagement`);
          }
          
          return parts.join(' and ') || 'Stable trend';
        }
        ```
      </controller-implementation>

      <response status="200">
        ```json
        {
          "timeWindow": "24h",
          "generatedAt": "2025-01-14T10:00:00Z",
          "trending": [
            {
              "tag": {
                "id": "tag-uuid",
                "name": "ai",
                "type": "AUTO"
              },
              "currentMentions": 18,
              "previousMentions": 10,
              "mentionVelocity": 80.0,
              "currentAvgEngagement": 70,
              "previousAvgEngagement": 50,
              "engagementVelocity": 40.0,
              "velocityScore": 56.0,
              "isNew": false,
              "whyTrending": "80% increase in mentions and 40% increase in engagement"
            }
          ]
        }
        ```
      </response>
    </endpoint>
  </api-specification>

  <frontend-implementation>
    <trending-widget>
      <location>apps/frontend/src/components/analytics/trending/trending-topics-widget.tsx</location>
      
      <implementation>
        ```typescript
        'use client';
        import { useState } from 'react';
        import useSWR from 'swr';
        import { useFetch } from '@gitroom/helpers/utils/custom.fetch';

        export const TrendingTopicsWidget = ({ groupId }) => {
          const fetch = useFetch();
          const [timeWindow, setTimeWindow] = useState<'24h' | '48h' | '72h'>('24h');

          const queryString = new URLSearchParams({
            timeWindow,
            ...(groupId && { groupId }),
            limit: '10'
          }).toString();

          const { data, isLoading } = useSWR(
            `/analytics/trending/topics?${queryString}`,
            async (url) => (await fetch(url)).json(),
            { refreshInterval: 600000 } // Refresh every 10 minutes
          );

          if (isLoading) return <LoadingComponent />;

          return (
            <div className="bg-third p-[24px] rounded-[8px]">
              <div className="flex justify-between items-center mb-[16px]">
                <h3 className="text-[18px]">üî• Trending Topics</h3>
                <TimeWindowSelector value={timeWindow} onChange={setTimeWindow} />
              </div>

              {data?.trending?.length > 0 ? (
                <div className="space-y-[12px]">
                  {data.trending.map((item, index) => (
                    <TrendingTopicItem 
                      key={item.tag.id} 
                      item={item} 
                      rank={index + 1} 
                    />
                  ))}
                </div>
              ) : (
                <EmptyState timeWindow={timeWindow} />
              )}
            </div>
          );
        };
        ```
      </implementation>

      <sub-components>
        <component name="TrendingTopicItem">
          ```typescript
          const TrendingTopicItem = ({ item, rank }) => (
            <div className="p-[12px] bg-forth rounded-[6px] flex items-center gap-[12px]">
              <div className="text-[20px] font-bold text-neutral-500">#{rank}</div>

              <div className="flex-1">
                <div className="flex items-center gap-[8px]">
                  <span className="font-medium">{item.tag.name}</span>
                  {item.tag.type === 'MANUAL' && (
                    <span className="text-xs px-[6px] py-[2px] bg-blue-500/20 text-blue-300 rounded-full">
                      CAMPAIGN
                    </span>
                  )}
                  {item.isNew && (
                    <span className="text-xs px-[6px] py-[2px] bg-green-500/20 text-green-300 rounded-full">
                      NEW
                    </span>
                  )}
                </div>

                <div className="text-sm text-neutral-400 mt-[4px]">
                  {item.whyTrending}
                </div>

                <div className="flex gap-[16px] mt-[6px] text-xs">
                  <span>
                    {item.currentMentions} mentions
                    {item.mentionVelocity > 0 && (
                      <span className="text-green-400 ml-[4px]">
                        ‚ÜóÔ∏è +{item.mentionVelocity}%
                      </span>
                    )}
                  </span>
                  <span>
                    {item.currentAvgEngagement} avg engagement
                    {item.engagementVelocity > 0 && (
                      <span className="text-green-400 ml-[4px]">
                        ‚ÜóÔ∏è +{item.engagementVelocity}%
                      </span>
                    )}
                  </span>
                </div>
              </div>

              <div className="text-right">
                <div className="text-[20px] font-bold text-green-400">
                  {item.velocityScore > 0 ? '+' : ''}{item.velocityScore}%
                </div>
                <div className="text-xs text-neutral-500">velocity</div>
              </div>
            </div>
          );
          ```
        </component>

        <component name="TimeWindowSelector">
          ```typescript
          const TimeWindowSelector = ({ value, onChange }) => (
            <div className="flex gap-[8px]">
              {['24h', '48h', '72h'].map(window => (
                <button
                  key={window}
                  onClick={() => onChange(window)}
                  className={`px-[12px] py-[6px] rounded-[4px] text-sm ${
                    value === window
                      ? 'bg-primary text-white'
                      : 'bg-forth text-neutral-400'
                  }`}
                >
                  {window}
                </button>
              ))}
            </div>
          );
          ```
        </component>

        <component name="EmptyState">
          ```typescript
          const EmptyState = ({ timeWindow }) => (
            <div className="text-center text-neutral-400 py-[24px]">
              <p>No trending topics in the last {timeWindow}</p>
              <p className="text-sm mt-[8px]">
                Try expanding the time window or selecting a different group
              </p>
            </div>
          );
          ```
        </component>
      </sub-components>
    </trending-widget>

    <integration-points>
      <dashboard-placement>
        <location>Insights section or Dashboard sidebar</location>
        <description>Widget displays alongside other analytics components</description>
      </dashboard-placement>

      <filter-integration>
        <description>Uses same filters as Dashboard (Story 3.2)</description>
        <shared-state>groupId from dashboard filter state</shared-state>
      </filter-integration>
    </integration-points>
  </frontend-implementation>

  <data-flow>
    <step order="1">Tags created by auto-tagging (Story 4.1)</step>
    <step order="2">Content published with tags assigned</step>
    <step order="3">Daily metrics tracked (Story 2.3)</step>
    <step order="4">User selects time window (24h/48h/72h)</step>
    <step order="5">Frontend calls /trending/topics API</step>
    <step order="6">Backend queries content + tags for two periods</step>
    <step order="7">Backend aggregates mentions and engagement per tag</step>
    <step order="8">Backend calculates velocity scores</step>
    <step order="9">Backend ranks and returns top N trending</step>
    <step order="10">Frontend displays trending widget with explanations</step>
  </data-flow>

  <performance-considerations>
    <query-optimization>
      <optimization>Index on (organizationId, publishedAt) for content queries</optimization>
      <optimization>Include tags and metrics in single query (reduce round-trips)</optimization>
      <optimization>Aggregate in application layer (acceptable for MVP)</optimization>
      <optimization>Limit to top 50 max results</optimization>
    </query-optimization>

    <caching>
      <strategy>Cache trending topics for 10 minutes</strategy>
      <key>org:{orgId}:trending:{timeWindow}:{groupId}</key>
      <invalidation>Time-based (10 min TTL)</invalidation>
      <rationale>Trending doesn't need real-time updates</rationale>
    </caching>

    <future-optimization>
      <pre-computation>Pre-compute trending scores via cron job</pre-computation>
      <materialized-view>Store trending calculations in separate table</materialized-view>
      <when-needed>If query performance degrades with scale</when-needed>
    </future-optimization>
  </performance-considerations>

  <testing-guidance>
    <unit-tests>
      <test name="velocity-calculation">
        <scenario>Calculate velocity with known inputs</scenario>
        <input>
          <current>mentions=18, avgEng=70</current>
          <previous>mentions=10, avgEng=50</previous>
        </input>
        <expected-output>
          <mention-velocity>80.0</mention-velocity>
          <engagement-velocity>40.0</engagement-velocity>
          <weighted-velocity>56.0</weighted-velocity>
        </expected-output>
      </test>

      <test name="new-tag-handling">
        <scenario>Tag appears for first time</scenario>
        <input>
          <current>mentions=5, avgEng=30</current>
          <previous>null (no previous data)</previous>
        </input>
        <expected-output>
          <velocity>100.0</velocity>
          <is-new>true</is-new>
        </expected-output>
      </test>

      <test name="zero-baseline">
        <scenario>Previous period has zero mentions</scenario>
        <input>
          <current>mentions=10, avgEng=50</current>
          <previous>mentions=0, avgEng=0</previous>
        </input>
        <expected-output>
          <velocity>100.0</velocity>
          <no-division-error>true</no-division-error>
        </expected-output>
      </test>

      <test name="declining-trend">
        <scenario>Current less than previous</scenario>
        <input>
          <current>mentions=5, avgEng=30</current>
          <previous>mentions=10, avgEng=50</previous>
        </input>
        <expected-output>
          <velocity>negative</velocity>
          <filtered-out>true (not in trending list)</filtered-out>
        </expected-output>
      </test>
    </unit-tests>

    <integration-tests>
      <test>API endpoint returns trending topics</test>
      <test>Time window parameter works correctly</test>
      <test>Group filtering produces correct results</test>
      <test>Trending list is properly ranked</test>
      <test>Empty result handled gracefully</test>
    </integration-tests>

    <frontend-tests>
      <test>Widget renders trending topics</test>
      <test>Time window selector changes data</test>
      <test>Rank numbers display correctly</test>
      <test>Velocity badges show up/down indicators</test>
      <test>Empty state displays when no trends</test>
    </frontend-tests>
  </testing-guidance>

  <validation-checklist>
    <check>Velocity calculation formula implemented correctly</check>
    <check>Weighted scoring (0.4 mentions + 0.6 engagement) works</check>
    <check>New tags handled (100% velocity)</check>
    <check>Zero baseline handled (no division by zero)</check>
    <check>Negative velocities filtered out</check>
    <check>Time window parsing works (24h/48h/72h)</check>
    <check>Group filtering applies correctly</check>
    <check>API returns top N ranked by velocity</check>
    <check>"Why trending" explanation generated</check>
    <check>Frontend widget displays correctly</check>
    <check>Time window selector works</check>
    <check>Edge cases handled gracefully</check>
  </validation-checklist>

  <related-files>
    <file path="docs/stories/4-1-auto-keyword-tagging-and-manual-campaign-tags.md" description="Tag source"/>
    <file path="docs/stories/2-3-ingest-daily-metrics.md" description="Engagement metrics source"/>
    <file path="docs/stories/3-1-manage-page-groups-and-assign-pages.md" description="Group filtering"/>
    <file path="libraries/nestjs-libraries/src/database/prisma/schema.prisma" description="Tag and content models"/>
  </related-files>

  <implementation-checklist>
    <backend>
      <task>Create AnalyticsTrendingService</task>
      <task>Implement getTrendingTopics() method</task>
      <task>Implement getTagMentions() helper</task>
      <task>Implement calculateVelocities() helper</task>
      <task>Implement parseTimeWindow() helper</task>
      <task>Add GET /trending/topics endpoint to controller</task>
      <task>Add generateWhyTrending() method</task>
      <task>Register service in modules</task>
      <task>Write unit tests for velocity calculation</task>
      <task>Write unit tests for edge cases</task>
      <task>Write integration tests for API</task>
      <task>Add Swagger documentation</task>
    </backend>

    <frontend>
      <task>Create TrendingTopicsWidget component</task>
      <task>Create TrendingTopicItem sub-component</task>
      <task>Create TimeWindowSelector sub-component</task>
      <task>Create EmptyState sub-component</task>
      <task>Implement data fetching with useSWR</task>
      <task>Add auto-refresh (10 min interval)</task>
      <task>Integrate into dashboard/insights page</task>
      <task>Add loading states</task>
      <task>Write component tests</task>
    </frontend>

    <documentation>
      <task>Update Swagger docs</task>
      <task>Document velocity formula</task>
      <task>Document time windows</task>
      <task>Add code comments</task>
    </documentation>
  </implementation-checklist>
</story-context>
